<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>LCDR LIVE DATA</title>
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
  <style>
    /* ... tu Twoje CSS bez zmian ... */
  </style>
</head>
<body>
  <!-- ... tu reszta Twojego HTML bez zmian ... -->

  <script>
    // ====== KONFIGURACJA: ======
    const spreadsheetId = '10W03bvKlVFlIUcxsHkzP_v_13gtnYRBmnrrO0ujB1bU';
    // Podmień na swoje GIDy (z paska adresu, gdy masz otwartą daną zakładkę)
    const sheetGids     = ['0', '193025884'];

    const urls = sheetGids.map(gid =>
      `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv&gid=${gid}`
    );
    // ==========================

    let latestData = [], currentDate = new Date();

    function parseCSV(text) {
      return text.trim().split('\n').map(r =>
        r.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g)?.map(c=>c.replace(/^"|"$/g,'').trim())||[]
      );
    }
    function normalizeDate(s) {
      if (!s) return '';
      if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
      if (/^\d{2}\/\d{2}\/\d{4}$/.test(s)) {
        const [d,m,y]=s.split('/'); return `${y}-${m}-${d}`;
      }
      return '';
    }
    function formatDate(d){ return d.toISOString().split('T')[0]; }

    // pobiera i parsuje pojedynczy arkusz CSV -> zwraca tablicę wpisów (OK/NDF)
    async function fetchSheet(url) {
      try {
        const res  = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        const rows = parseCSV(text);
        const hdr  = rows[0].map(h=>h.toUpperCase());
        const iDate   = hdr.findIndex(h=>h==='DATE'||h==='DATA'),
              iStatus = hdr.findIndex(h=>h==='STATUS'),
              iName   = hdr.findIndex(h=>h==='NAME'||h==='IMIĘ'||h==='IMIE'),
              iSN     = hdr.findIndex(h=>h==='SERIAL NUMBER'||h==='NUMER SERYJNY'),
              iComm   = hdr.findIndex(h=>h==='COMMENT'||h==='KOMENTARZ');

        const tgt = formatDate(currentDate);
        return rows.slice(1).reduce((arr, r) => {
          const d  = normalizeDate(r[iDate]),
                st = (r[iStatus]||'').toUpperCase();
          if (d===tgt && (st==='OK'||st==='NDF')) {
            arr.push({
              serial:  r[iSN]   || '–',
              status:  st,
              name:    (r[iName]||'–').trim(),
              comment: r[iComm] || '–'
            });
          }
          return arr;
        }, []);
      } catch (e) {
        console.warn('✖ Nie udało się pobrać arkusza:', url, e);
        return [];  // zamiast return[], pomijamy tylko ten arkusz
      }
    }

    // ładuje wszystkie zakładki równolegle i scala wyniki
    async function loadData() {
      const sheets = await Promise.all(urls.map(fetchSheet));
      return sheets.flat();
    }

    function render(data) {
      if (!data.length) {
        console.warn('⚠️ Brak danych dla tej daty – zostawiam poprzednie.');
        return;
      }
      latestData = data.sort((a,b)=>a.name.localeCompare(b.name));

      // --- render tabeli danych ---
      const dtb = document.createElement('tbody');
      latestData.forEach(it=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td class="status-${it.status.toLowerCase()}">${it.status}</td>
          <td>${it.serial}</td>
          <td>${it.name}</td>
          <td>${it.comment}</td>`;
        dtb.appendChild(tr);
      });
      document.getElementById('data-table').tBodies[0].replaceWith(dtb);

      // --- render podsumowania ---
      const names = [...new Set(latestData.map(x=>x.name))].sort();
      const stb   = document.createElement('tbody');
      names.forEach(name=>{
        const ok  = latestData.filter(x=>x.name===name&&x.status==='OK').length;
        const ndf = latestData.filter(x=>x.name===name&&x.status==='NDF').length;
        const tr  = document.createElement('tr');
        tr.innerHTML = `<td>${name}</td><td class="ok">${ok}</td><td class="ndf">${ndf}</td>`;
        stb.appendChild(tr);
      });
      document.getElementById('summary-table').tBodies[0].replaceWith(stb);
    }

    function setDate(type) {
      currentDate = new Date();
      if (type==='yesterday') currentDate.setDate(currentDate.getDate()-1);
      document.getElementById('today-date').textContent = formatDate(currentDate);
      loadData().then(render);
    }
    function toggleTheme() {
      document.body.classList.toggle('dark-mode');
      localStorage.setItem('theme',
        document.body.classList.contains('dark-mode')?'dark':'light'
      );
    }
    function exportToExcel() {
      const ws = XLSX.utils.json_to_sheet(
        latestData.map(d=>({
          STATUS:d.status,
          'SERIAL NUMBER':d.serial,
          NAME:d.name,
          COMMENT:d.comment
        }))
      );
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb,ws,'LCDR Data');
      XLSX.writeFile(wb,`LCDR_DATA_${formatDate(currentDate)}.xlsx`);
    }

    // ---- start ----
    if (localStorage.getItem('theme')==='dark') {
      document.body.classList.add('dark-mode');
    }
    setDate('today');
    (function loop(){
      setTimeout(()=>{
        loadData()
          .then(render)
          .catch(e=>console.error('🔴 błąd odświeżania',e))
          .finally(loop);
      }, 30000);
    })();
  </script>
</body>
</html>
